%Erstemal, dass ich mit Latex arbeite, daher bitte nicht schlagen :D
\documentclass[a4paper, 11pt]{report}

\usepackage[ngerman]{babel}
\usepackage[latin1]{inputenc}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{txfonts}
\usepackage{pstricks}

\newcommand{\N}{\varmathbb{N}}
\newcommand{\Z}{\varmathbb{Z}}
\newcommand{\Q}{\varmathbb{Q}}
\newcommand{\R}{\varmathbb{R}}
\newcommand{\C}{\varmathbb{C}}
\begin{document}

\tableofcontents

\newpage

\chapter{Einführung}
\section{Inhalt}
Übertragung (Speicherung) von Daten:\\
Schutz vor:
\begin{itemize}
	\item[-] zufälligen oder systematischen (physikalischen bedingten) Störungen
	\item[-] Abhören, absichtliche Veränderung von Dritten (Kryptologie / Verschlüsselung)
\end{itemize}
\underline{Kryptologie:}
\begin{itemize}
	\item[-] symmetrische Verfahren
	\item[-] asymmetrische Verfahren (Public-Key Verfahren)
	\item[-] Authentifizierung
	\item[-] Signaturen
\end{itemize}
\underline{Codierungstheorie}
\begin{itemize}
	\item[-] Fehlererkennung und Fehlerkorrektur
	\item[-] lineare Blockcodes
	\item[-] Decodierverfahren
\end{itemize}

\newpage

\chapter{Kryptologie}

\section{Grundbegriffe und einfache Verfahren}
\begin{figure}[h]
	\centering
	\includegraphics{./img/krypto_schaubild.pdf}
	\caption{Schaubild der Kryptologie}
	\label{img:Schaubild}
\end{figure}

\subsection{Verschlüsselung erfordert}
\begin{itemize}
	\item[-] Verschlüsselungsverfahren, Algorithmus (Funktion)
	\item[-] Schlüssel $k_{e}$ (encryption key)
\end{itemize}
$E(m,k_e)=c$\\
$E$=Verschl.Fkt., $m$=Klartext, $c$=Chiffretext\\
$E(m_1,k_e)\neq E(m,k_e)$ für $m_1\neq m_2$\\
$D(c,k_d)=m$\\
($k_d$ zu $k_e$ gehöriger Dechiffrierschlüssel!)\\

$k_d=k_e$ (oder $k_d$ leicht aus $k_e$ zu berechnen):\\
\underline{symmetrisches Verschl.verf.}, ansonsten \underline{asymm. Verschl.verf.}. Ist $k_d$ nur sehr schwer (oder garnicht) zu $k_e$ berechenbar, so kann $k_e$ veröffentl. werden:\\
\underline{Public-Key-Verfahren}.
\subsection{Beispiel für (nicht sicheres) symm. Verfahren}
\begin{itemize}
	\item[a)] $R=S=\left\{0,1,\ldots,25\right\}$\\
	Verfahren: Verschiebechiffre\\
	Schlüssel: $i \in \left\{0,1,\ldots,25\right\}$\\
	Verfahren $ x \in \R \longrightarrow x+i$ mod $26=y$\\
	$y\longmapsto y-i$ mod $26 = y$\\
	$m=x_1 ... x_2 \longrightarrow  c = (x_1 + i$ mod $26) \ldots (x_n +i$ mod $ 26)$, $E(m,i)$\\
	Unsicher, weil Schlüsselmenge klein ist (Brute Force Angriff).
	\item[b)] R,S, Schlüsselmenge=Menge aller Permutationen von $\left\{1,\ldots,25\right\}=S_{26}$\\
	Verschl.: Wähle Permuation $\pi$\\
	$x \in \R \longrightarrow \pi (x)=y$\\
	Entschl.: $y \longrightarrow \pi^{-1}(y)=x$\\
	$m=x_1 \ldots x_r \rightarrow c=\pi(x_1)\ldots\pi(x_r)$\\
	$\begin{pmatrix}
  0 & 1 & 2 & \ldots & 25 \\
  3 & 17 & 4 & \ldots & 13
	\end{pmatrix}
	\longrightarrow \pi(0)=3$, u.s.w.\\
	Anzahl der Permutationen: $\left|{S_{26}}\right|=26!\approx4\cdot10^{26} \longrightarrow$ Brute-Force Angriff nicht mehr möglich! \\
	Warum? Man muss im Schnitt 50\% der Permutationen testen. Angenommen man könnte $10^12$ Perm. pro Sekunde testen.\\
	Aufwand: $2\cdot10^{14}$ Sekunden $\approx 6.000.000$ Jahre\\
	Trotzdem unsicher!\\
	Grund: Charakteristiches Häufigkeitsverteilung von Buchstaben in natürlichspr. Texten.
\end{itemize}
Verfahren beinhalten viele Verschlüsselungsmöglichkeiten, abhängig von der Auswahl des Schlüssels.\\
Verfahren bekannt, aber Schlüssel $k_d$ geheim!\\
\subsection{Prinzip von Kerkhoffs (1835-1903)}
Sicherheit eines Verschlüsselungsverfahren darf nicht von der Geheimhaltung des Verfahrens, sondern nur von der Geheimhaltung des verwendeten Schlüssels abhängen!
%
%	Ende Stunde vom 29.10.2009
%
\\\\
Kryptologie besteht aus Kryptographie (Entwurf) und der Kryptoanalyse (Angriff).
Angriffserfolge:
\begin{itemize}
	\item[-] Schlüssel $k_d$ wird gefunden
	\item[-] Eine zu der Dechiffrierfunktion $D(\cdot,k_d)$ äquivalente Funktion finden ohne Kenntnis von $k_d$
	\item[-] gewisste Chiffretexte werden entschlüsselt
\end{itemize}
Arten von Angriffen
\begin{itemize}
	\item[-] Ciphertext-Only Angriff
	\item[-] Known-Plaintext Angriff
	\item[-] Chosen-Plaintext Angriff
	\item[-] Chosen-Ciphertext Angriff
\end{itemize}

\chapter{One-Time-Pad und perfekte Sicherheit}
Lauftextverschlüsselung\\
Alphabet $\Z_k=\{0,1,\ldots,k-1\}$\\
In $\Z_k$ kann man addieren und multiplizieren mit mod $k$.\\
Klartext $x_1,x_2,\ldots,x_n$\\
Schlüsselwort $k_1,k_2,\ldots,k_n$\\
$x_1 + k_1$ mod $k$, $x_n + k_n$ mod $k \leftarrow$ Chiffretext\\
Mit natürlichsprachlichen Texten ist das Verfahren unsicher.\\
$\Z_2=\{0,1\}$, $1 \oplus 1 = 0 = 0 \oplus 0$, $0 \oplus 1 = 1 = 1 \oplus 0 \Rightarrow XOR$\\
Klartext in $\Z_2^n=\{(x_1,\ldots,x_n):x_i \in \Z_2\}$
Schlüssel: Zufallsfolge über $\Z_2$ der Länge $n$. $m$ Klartext, $k$ Zufallsfolge (beide Länge $n$)\\
$c=m\oplus k$, $(x_1,\ldots,x_n)\oplus(k_1,\ldots,k_n):=(x_1\oplus k_1,\ldots,x_n\oplus k_n)$\\
\section{One-Time-Pad}
Schlüssel $k$ darf nur einmal verwendet werden!\\
$m_1\oplus k=c_1, m_2 \oplus k=c_2,c_1\oplus c_2=m_1\oplus k \oplus m_2\oplus k=m_1\oplus m_2$\\
Wieder nur Lauftext $\rightarrow$ unsicher!\\
$m_1$ und $m_2$ lässt sich ermitteln.\\
Zufallsfolge der Länge $n$: eigentlich unsinniger Begriff. Da jedes Bit unabhängig von anderen mit Wahrscheinlichkeit $\frac{1}{2}$ erzeugt wird (Output einer binär symmetrischen Quelle)\\
Jede Folge der Länge $n$ ist gleich wahrscheinlich (Wahrscheinlichkeit $\frac{1}{2} n$\\
One-Time-Pad ist perfekt sicher.
\section{Perfekte Sicherheit}
Ein Verschlüsselungsverfahren ist perfekt sicher, falls gilt: Für jeden Klartext $m$ und jedem Chiffretext $c$ (der festen Länge $n$)\\
$pr(m|c)=pr(m)$\\
$pr(m|c)\rightarrow$ A-posteriori-Wahrscheinlichkeit (Wahrscheinlichkeit, dass $m$ Klartext, wenn $c$ empfangen wurde)\\
$pr(m)\rightarrow$ A-priori-Wahrscheinlichkeit\\
\textbf{Beispiel:} Substitutionschiffre aus Kapitel 2.\\
$n=5, m=HALLO, pr(m)>0$\\
Ang:$c=QITUA$ wird empfangen, $LL\neq TU \rightarrow pr(m|c)=0$\\
nicht perfekt sicher.\\
One-Time-Pad ist perfekt sicher. \\
(Bayes'sche Formel) $m\oplus k$\\
Jede Folge $c$ lässt sich mit geeignetem $k$ in der Form $c=m\oplus k$ erhalten.\\
Wähle $k=m\oplus c$, $m\oplus k=m\oplus m \oplus c=c$\\
Bei gegebenem $m$ und zufällige gewählten Schlüssel $k$ ist jeder Chiffretext gleichwertig.
\chapter{Symmetrische Blockchiffre}
\section{Blockchiffre}
Zerlege Klartext in Blöcke (Strings) der Länge $n$.  Jeder Block wird einzeln verschlüsselt (in der Regel wieder in einem Block der Länge $n$). Gleiche Blöcke werden gleich verschlüsselt.\\
Wieviele Blockchiffren der Länge $n$ gibt es?\\
Alphabet $\Z_2=\{0,1\}$\\
$|\{\underbrace{(0,\ldots,0)}_{Block},(0,\ldots,1),\ldots,(1,\ldots,1)\}| = 2^n$\\
Blockchiffre = Permuation der $2^n$ Blöcke.\\
$(2^n)!$ Blockchiffre\\
Wenn alle verwendet werden:\\
Schlüssel = Permuation der $2^n$ Blöcke\\
$(x_{1,1},\ldots,x_{1,n},x_{2,1},\ldots,x_{2,n},\ldots)$ \ \ \fbox{$n\cdot 2^n$ Bit}\\
Zur Speicherung eines Schlüssels werden $n \cdot 2^n$ Bit benötigt.\\
Zum Beispiel:\\
$n=64, \ 64 \cdot 2^{64}=2^{70}\approx$ 1 ZetaByte $\approx$ 1 Milliarde Festplatten à 1 TB\\
\textbf{Illusional!}\\
Konsequenz:\ Verwende Verfahren, wo nur ein kleiner Teil der Permutation als Schlüssel verwendet wird und so sich die Schlüssel dann in kürzerer Fom darstellt.
%
% Ende zweiter Vorlesung
%

\newpage
\end{document}
